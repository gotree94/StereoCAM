# Module 02: ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹¤ìŠµ

[![ë‚œì´ë„](https://img.shields.io/badge/ë‚œì´ë„-â­â­â­_ì¤‘ê¸‰-yellow.svg)]()
[![ì˜ˆìƒì‹œê°„](https://img.shields.io/badge/ì˜ˆìƒì‹œê°„-10--15ì‹œê°„-blue.svg)]()
[![ì„ ìˆ˜ì§€ì‹](https://img.shields.io/badge/ì„ ìˆ˜ì§€ì‹-Module_01_ì™„ë£Œ-orange.svg)]()

---

## ğŸ“‹ ëª¨ë“ˆ ê°œìš”

| í•­ëª© | ë‚´ìš© |
|------|------|
| **í•™ìŠµ ëª©í‘œ** | USB ì›¹ìº  2ëŒ€ì˜ ìŠ¤í…Œë ˆì˜¤ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ì „ ë§ˆìŠ¤í„° |
| **í•µì‹¬ í‚¤ì›Œë“œ** | ì²´ìŠ¤ë³´ë“œ, ë‚´ë¶€ íŒŒë¼ë¯¸í„°, ì™¸ë¶€ íŒŒë¼ë¯¸í„°, ì •ë¥˜ ë§µ |
| **ì‚°ì¶œë¬¼** | ìº˜ë¦¬ë¸Œë ˆì´ì…˜ íŒŒë¼ë¯¸í„° íŒŒì¼ (.yaml), ì •ë¥˜ëœ ì´ë¯¸ì§€ |

---

## ğŸ“š ëª©ì°¨

1. [ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê°œìš”](#1-ìº˜ë¦¬ë¸Œë ˆì´ì…˜-ê°œìš”) : ì „ì²´ íŒŒì´í”„ë¼ì¸ íë¦„ë„, í•„ìš”í•œ íŒŒë¼ë¯¸í„° ì„¤ëª…
2. [í•˜ë“œì›¨ì–´ ì¤€ë¹„](#2-í•˜ë“œì›¨ì–´-ì¤€ë¹„) : ë§ˆìš´íŠ¸ êµ¬ì„±, ì¹´ë©”ë¼ ì¸ë±ìŠ¤ í™•ì¸ ë°©ë²•
3. [ì²´ìŠ¤ë³´ë“œ íŒ¨í„´ ì¤€ë¹„](#3-ì²´ìŠ¤ë³´ë“œ-íŒ¨í„´-ì¤€ë¹„) : íŒ¨í„´ ì‚¬ì–‘, ìƒì„± ì½”ë“œ, ì¤€ë¹„ íŒ
4. [ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì´ë¯¸ì§€ ìº¡ì²˜](#4-ìº˜ë¦¬ë¸Œë ˆì´ì…˜-ì´ë¯¸ì§€-ìº¡ì²˜) : ìº¡ì²˜ ê°€ì´ë“œë¼ì¸, ìº¡ì²˜ í”„ë¡œê·¸ë¨ ì½”ë“œ
5. [ë‹¨ì¼ ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜](#5-ë‹¨ì¼-ì¹´ë©”ë¼-ìº˜ë¦¬ë¸Œë ˆì´ì…˜) : K, D ì¶”ì¶œ ì´ë¡  ë° êµ¬í˜„
6. [ìŠ¤í…Œë ˆì˜¤ ìº˜ë¦¬ë¸Œë ˆì´ì…˜](#6-ìŠ¤í…Œë ˆì˜¤-ìº˜ë¦¬ë¸Œë ˆì´ì…˜) : R, T ì¶”ì¶œ, ì „ì²´ êµ¬í˜„ í´ë˜ìŠ¤
7. [ìŠ¤í…Œë ˆì˜¤ ì •ë¥˜](#7-ìŠ¤í…Œë ˆì˜¤-ì •ë¥˜) : ì •ë¥˜ ë§µ ìƒì„±, ì‹œê°í™”
8. [ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê²€ì¦](#8-ìº˜ë¦¬ë¸Œë ˆì´ì…˜-ê²€ì¦) : í’ˆì§ˆ ì§€í‘œ, ê²€ì¦ ì½”ë“œ
9. [ì‹¤ìŠµ ì½”ë“œ](#9-ì‹¤ìŠµ-ì½”ë“œ) : ì „ì²´ íŒŒì´í”„ë¼ì¸ í†µí•©
10. [íŠ¸ëŸ¬ë¸”ìŠˆíŒ…](#10-íŠ¸ëŸ¬ë¸”ìŠˆíŒ…) : ì¼ë°˜ì ì¸ ë¬¸ì œì™€ í•´ê²°ì±…


ğŸ“ í¬í•¨ëœ ì½”ë“œ
  * generate_checkerboard.py - ì²´ìŠ¤ë³´ë“œ íŒ¨í„´ ìƒì„±
  * capture_calibration_images.py - ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì´ë¯¸ì§€ ìº¡ì²˜
  * single_camera_calibration.py - ë‹¨ì¼ ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜
  * stereo_calibration.py - ìŠ¤í…Œë ˆì˜¤ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ í´ë˜ìŠ¤
  * visualize_rectification.py - ì •ë¥˜ ê²°ê³¼ ì‹œê°í™”
  * validate_calibration.py - ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê²€ì¦
  * full_calibration_pipeline.py - ì „ì²´ íŒŒì´í”„ë¼ì¸

---

## 1. ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê°œìš”

### 1.1 ìº˜ë¦¬ë¸Œë ˆì´ì…˜ì´ í•„ìš”í•œ ì´ìœ 

```
ì‹¤ì œ ì¹´ë©”ë¼                      ì´ìƒì ì¸ ì¹´ë©”ë¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â•­â”€â”€â”€â”€â”€â”€â•®    â”‚                â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ ì™œê³¡  â”‚    â”‚      â†’        â”‚  â”‚ ì§ì„   â”‚    â”‚
â”‚  â”‚ ë°œìƒ  â”‚    â”‚   ìº˜ë¦¬ë¸Œë ˆì´ì…˜  â”‚  â”‚ ìœ ì§€  â”‚    â”‚
â”‚  â•°â”€â”€â”€â”€â”€â”€â•¯    â”‚                â”‚  â””â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

ìº˜ë¦¬ë¸Œë ˆì´ì…˜ìœ¼ë¡œ ì–»ëŠ” ê²ƒ:

| íŒŒë¼ë¯¸í„° | ë‚´ìš© | ìš©ë„ |
|----------|------|------|
| **ë‚´ë¶€ íŒŒë¼ë¯¸í„° (K)** | ì´ˆì ê±°ë¦¬, ì£¼ì  | íˆ¬ì˜ ê³„ì‚° |
| **ì™œê³¡ ê³„ìˆ˜ (D)** | ë°©ì‚¬/ì ‘ì„  ì™œê³¡ | ì´ë¯¸ì§€ ë³´ì • |
| **ì™¸ë¶€ íŒŒë¼ë¯¸í„° (R, T)** | ì¹´ë©”ë¼ ê°„ íšŒì „/ì´ë™ | ìŠ¤í…Œë ˆì˜¤ ê¸°í•˜ |

### 1.2 ìº˜ë¦¬ë¸Œë ˆì´ì…˜ íŒŒì´í”„ë¼ì¸

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì „ì²´ íë¦„                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  [1] ì²´ìŠ¤ë³´ë“œ ì¤€ë¹„        [2] ì´ë¯¸ì§€ ìº¡ì²˜ (30ì¥+)             â”‚
â”‚         â”‚                        â”‚                         â”‚
â”‚         â–¼                        â–¼                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚ 9x6 íŒ¨í„´    â”‚          â”‚ ë‹¤ì–‘í•œ ê°ë„  â”‚                  â”‚
â”‚  â”‚ 25mm ì •ì‚¬ê° â”‚          â”‚ ë‹¤ì–‘í•œ ê±°ë¦¬  â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                                  â”‚                         â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚         â–¼                        â–¼                    â–¼    â”‚
â”‚  [3] ë‹¨ì¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜     [4] ìŠ¤í…Œë ˆì˜¤ ìº˜ë¦¬ë¸Œë ˆì´ì…˜           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚ K1, D1      â”‚          â”‚ R, T        â”‚                  â”‚
â”‚  â”‚ K2, D2      â”‚          â”‚ E, F        â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚         â”‚                        â”‚                         â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚                      â–¼                                     â”‚
â”‚              [5] ìŠ¤í…Œë ˆì˜¤ ì •ë¥˜                               â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚              â”‚ R1, R2      â”‚                               â”‚
â”‚              â”‚ P1, P2      â”‚                               â”‚
â”‚              â”‚ Q           â”‚                               â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                      â”‚                                     â”‚
â”‚                      â–¼                                     â”‚
â”‚              [6] ê²€ì¦ ë° ì €ì¥                                â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚              â”‚ .yaml íŒŒì¼  â”‚                               â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. í•˜ë“œì›¨ì–´ ì¤€ë¹„

### 2.1 ìŠ¤í…Œë ˆì˜¤ ì¹´ë©”ë¼ ë§ˆìš´íŠ¸

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚          ë§ˆìš´íŠ¸ í”Œë ˆì´íŠ¸             â”‚
                    â”‚                                     â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”       â”‚       â† 85mm+ â†’                    â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”
     â”‚ ğŸ“·   â”‚â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”‚  ğŸ“·  â”‚
     â”‚ LEFT â”‚       â”‚                                     â”‚       â”‚RIGHT â”‚
     â””â”€â”€â”€â”€â”€â”€â”˜       â”‚                                     â”‚       â””â”€â”€â”€â”€â”€â”€â”˜
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â”‚ ì‚¼ê°ëŒ€
                                   â•±â•²
```

### 2.2 ì¤‘ìš” ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] ë‘ ì¹´ë©”ë¼ê°€ **ë™ì¼ ëª¨ë¸**ì¸ê°€?
- [ ] ë² ì´ìŠ¤ë¼ì¸(ì¹´ë©”ë¼ ê°„ê²©)ì´ **85mm ì´ìƒ**ì¸ê°€?
- [ ] ë‘ ì¹´ë©”ë¼ ë Œì¦ˆê°€ **ê°™ì€ ë†’ì´**ì— ìˆëŠ”ê°€?
- [ ] ë‘ ì¹´ë©”ë¼ê°€ **í‰í–‰í•˜ê²Œ** ì •ë ¬ë˜ì—ˆëŠ”ê°€?
- [ ] ë§ˆìš´íŠ¸ê°€ **ë‹¨ë‹¨íˆ ê³ ì •**ë˜ì–´ í”ë“¤ë¦¼ì´ ì—†ëŠ”ê°€?
- [ ] USB ì¼€ì´ë¸”ì´ **ê°ê° ë‹¤ë¥¸ USB ì»¨íŠ¸ë¡¤ëŸ¬**ì— ì—°ê²°ë˜ì—ˆëŠ”ê°€?

### 2.3 ì¹´ë©”ë¼ ì¸ë±ìŠ¤ í™•ì¸

```bash
# Linuxì—ì„œ ì¹´ë©”ë¼ ì¥ì¹˜ í™•ì¸
ls /dev/video*

# ì¼ë°˜ì ì¸ ê²°ê³¼:
# /dev/video0  â† ì™¼ìª½ ì¹´ë©”ë¼ (ë˜ëŠ” ë‚´ì¥ ì›¹ìº )
# /dev/video1  â† ë©”íƒ€ë°ì´í„°
# /dev/video2  â† ì˜¤ë¥¸ìª½ ì¹´ë©”ë¼
# /dev/video3  â† ë©”íƒ€ë°ì´í„°
```

```python
# Pythonìœ¼ë¡œ ì¹´ë©”ë¼ ì¸ë±ìŠ¤ ì°¾ê¸°
import cv2

for i in range(10):
    cap = cv2.VideoCapture(i)
    if cap.isOpened():
        ret, frame = cap.read()
        if ret:
            print(f"Camera index {i}: Available ({frame.shape})")
        cap.release()
```

---

## 3. ì²´ìŠ¤ë³´ë“œ íŒ¨í„´ ì¤€ë¹„

### 3.1 íŒ¨í„´ ì‚¬ì–‘

| í•­ëª© | ê¶Œì¥ê°’ | ì„¤ëª… |
|------|--------|------|
| ë‚´ë¶€ ì½”ë„ˆ ìˆ˜ | 9Ã—6 ë˜ëŠ” 10Ã—7 | ê°€ë¡œÃ—ì„¸ë¡œ ì½”ë„ˆ ê°œìˆ˜ |
| ì •ì‚¬ê°í˜• í¬ê¸° | 25mm | ì¸¡ì • ì •í™•ë„ë¥¼ ìœ„í•´ ì •í™•í•´ì•¼ í•¨ |
| ì¬ì§ˆ | ë‹¨ë‹¨í•œ íŒ | í‰í‰í•´ì•¼ í•¨ (ì¢…ì´ íœ˜ì–´ì§ ì£¼ì˜) |
| ìƒ‰ìƒ | í‘ë°±, ê³ ëŒ€ë¹„ | ì½”ë„ˆ ê²€ì¶œ ì •í™•ë„ |

### 3.2 ì²´ìŠ¤ë³´ë“œ ìƒì„±

```python
"""
generate_checkerboard.py
ìº˜ë¦¬ë¸Œë ˆì´ì…˜ìš© ì²´ìŠ¤ë³´ë“œ íŒ¨í„´ ìƒì„±
"""

import numpy as np
import cv2

def generate_checkerboard(rows=7, cols=10, square_size_mm=25, dpi=300):
    """
    ì¸ì‡„ìš© ì²´ìŠ¤ë³´ë“œ íŒ¨í„´ ìƒì„±
    
    Parameters:
    - rows: ì„¸ë¡œ ì •ì‚¬ê°í˜• ê°œìˆ˜
    - cols: ê°€ë¡œ ì •ì‚¬ê°í˜• ê°œìˆ˜
    - square_size_mm: ì •ì‚¬ê°í˜• í•œ ë³€ ê¸¸ì´ (mm)
    - dpi: ì¸ì‡„ í•´ìƒë„
    """
    
    # í”½ì…€ í¬ê¸° ê³„ì‚°
    mm_to_inch = 1 / 25.4
    square_size_px = int(square_size_mm * mm_to_inch * dpi)
    
    # ì´ë¯¸ì§€ ìƒì„±
    img_height = rows * square_size_px
    img_width = cols * square_size_px
    
    checkerboard = np.zeros((img_height, img_width), dtype=np.uint8)
    
    for i in range(rows):
        for j in range(cols):
            if (i + j) % 2 == 0:
                y1 = i * square_size_px
                y2 = (i + 1) * square_size_px
                x1 = j * square_size_px
                x2 = (j + 1) * square_size_px
                checkerboard[y1:y2, x1:x2] = 255
    
    # ì—¬ë°± ì¶”ê°€
    margin = square_size_px
    bordered = np.ones((img_height + 2*margin, img_width + 2*margin), dtype=np.uint8) * 255
    bordered[margin:margin+img_height, margin:margin+img_width] = checkerboard
    
    # ì •ë³´ í…ìŠ¤íŠ¸ ì¶”ê°€
    info_text = f"Checkerboard {cols}x{rows} | Square: {square_size_mm}mm | Inner corners: {cols-1}x{rows-1}"
    cv2.putText(bordered, info_text, (margin, margin//2), 
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, 0, 1)
    
    return bordered

if __name__ == "__main__":
    # ì²´ìŠ¤ë³´ë“œ ìƒì„± (10x7 ì •ì‚¬ê°í˜• = 9x6 ë‚´ë¶€ ì½”ë„ˆ)
    checkerboard = generate_checkerboard(rows=7, cols=10, square_size_mm=25, dpi=300)
    
    # ì €ì¥
    cv2.imwrite("checkerboard_10x7_25mm.png", checkerboard)
    print("âœ… ì²´ìŠ¤ë³´ë“œ ì €ì¥ë¨: checkerboard_10x7_25mm.png")
    print("   A4 ìš©ì§€ì— 'ì‹¤ì œ í¬ê¸°'ë¡œ ì¸ì‡„í•˜ì„¸ìš”.")
    print(f"   ë‚´ë¶€ ì½”ë„ˆ: 9 x 6")
    print(f"   ì •ì‚¬ê°í˜• í¬ê¸°: 25mm")
```

### 3.3 ì²´ìŠ¤ë³´ë“œ ì¤€ë¹„ íŒ

1. **ì •í™•í•œ í¬ê¸°ë¡œ ì¸ì‡„**: í”„ë¦°í„° ì„¤ì •ì—ì„œ "ì‹¤ì œ í¬ê¸°" ë˜ëŠ” "100%" ì„ íƒ
2. **í¬ê¸° ê²€ì¦**: ìë¡œ ì •ì‚¬ê°í˜• í¬ê¸° ì¸¡ì • (ì˜¤ì°¨ Â±0.5mm ì´ë‚´)
3. **í‰í‰í•œ íŒì— ë¶€ì°©**: í¼ë³´ë“œ, MDF, ì•„í¬ë¦´ íŒ ë“±
4. **íœ˜ì–´ì§ ë°©ì§€**: ì–‘ë©´ í…Œì´í”„ë¡œ ì „ì²´ ë©´ì  ë¶€ì°©

---

## 4. ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì´ë¯¸ì§€ ìº¡ì²˜

### 4.1 ìº¡ì²˜ ê°€ì´ë“œë¼ì¸

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ì´ë¯¸ì§€ ìº¡ì²˜ ê°€ì´ë“œ                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  âœ… ì˜¬ë°”ë¥¸ ì˜ˆ                    âŒ ì˜ëª»ëœ ì˜ˆ               â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚ â–¦â–¦â–¦â–¦â–¦â–¦  â”‚ ì „ì²´ ë³´ì„           â”‚  â–¦â–¦â–¦    â”‚ ì˜ë¦¼          â”‚
â”‚  â”‚ â–¦â–¦â–¦â–¦â–¦â–¦  â”‚                    â”‚  â–¦â–¦â–¦    â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚   â—‡â—‡â—‡   â”‚ ê¸°ìš¸ì–´ì§„ ê°ë„       â”‚ â–¦â–¦â–¦â–¦â–¦â–¦  â”‚ í•­ìƒ ì •ë©´ë§Œ   â”‚
â”‚  â”‚  â—‡â—‡â—‡    â”‚ (ë‹¤ì–‘ì„± í•„ìš”)       â”‚ â–¦â–¦â–¦â–¦â–¦â–¦  â”‚ (ë‹¤ì–‘ì„± ë¶€ì¡±) â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚â–¦        â”‚ ì´ë¯¸ì§€ ê°€ì¥ìë¦¬      â”‚         â”‚ ì¤‘ì•™ì—ë§Œ      â”‚
â”‚  â”‚    â–¦    â”‚ ì „ì²´ í™œìš©           â”‚   â–¦â–¦â–¦   â”‚ (ì™œê³¡ ë³´ì •â†“)  â”‚
â”‚  â”‚       â–¦ â”‚                    â”‚         â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 ìº¡ì²˜ ìš”êµ¬ì‚¬í•­

| ìš”êµ¬ì‚¬í•­ | ìµœì†Œ | ê¶Œì¥ | ì„¤ëª… |
|----------|------|------|------|
| ì´ë¯¸ì§€ ìˆ˜ | 15ìŒ | 30-50ìŒ | ë§ì„ìˆ˜ë¡ ì •í™• |
| ì²´ìŠ¤ë³´ë“œ ê°ë„ | 3ê°€ì§€ | ë‹¤ì–‘í•˜ê²Œ | X, Y, Zì¶• íšŒì „ |
| ì²´ìŠ¤ë³´ë“œ ê±°ë¦¬ | 2ê°€ì§€ | ë‹¤ì–‘í•˜ê²Œ | 0.5m ~ 2m |
| ì²´ìŠ¤ë³´ë“œ ìœ„ì¹˜ | ì¤‘ì•™ë§Œ | ì „ì²´ ì˜ì—­ | íŠ¹íˆ ê°€ì¥ìë¦¬ ì¤‘ìš” |

### 4.3 ìº¡ì²˜ í”„ë¡œê·¸ë¨

```python
"""
capture_calibration_images.py
ìŠ¤í…Œë ˆì˜¤ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ìš© ì´ë¯¸ì§€ ìº¡ì²˜
"""

import cv2
import os
from datetime import datetime

class StereoCalibrationCapture:
    def __init__(self, left_idx=0, right_idx=2, width=1920, height=1080):
        """
        Parameters:
        - left_idx: ì™¼ìª½ ì¹´ë©”ë¼ ì¸ë±ìŠ¤
        - right_idx: ì˜¤ë¥¸ìª½ ì¹´ë©”ë¼ ì¸ë±ìŠ¤
        - width, height: í•´ìƒë„
        """
        self.cap_left = cv2.VideoCapture(left_idx)
        self.cap_right = cv2.VideoCapture(right_idx)
        
        # í•´ìƒë„ ì„¤ì •
        for cap in [self.cap_left, self.cap_right]:
            cap.set(cv2.CAP_PROP_FRAME_WIDTH, width)
            cap.set(cv2.CAP_PROP_FRAME_HEIGHT, height)
            cap.set(cv2.CAP_PROP_FOURCC, cv2.VideoWriter_fourcc(*'MJPG'))
        
        # ì €ì¥ ë””ë ‰í† ë¦¬
        self.save_dir = f"calibration_images_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        os.makedirs(f"{self.save_dir}/left", exist_ok=True)
        os.makedirs(f"{self.save_dir}/right", exist_ok=True)
        
        self.image_count = 0
        
        # ì²´ìŠ¤ë³´ë“œ íŒŒë¼ë¯¸í„°
        self.checkerboard_size = (9, 6)  # ë‚´ë¶€ ì½”ë„ˆ ìˆ˜
        
    def capture_loop(self):
        """ë©”ì¸ ìº¡ì²˜ ë£¨í”„"""
        
        print("="*60)
        print("ìŠ¤í…Œë ˆì˜¤ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì´ë¯¸ì§€ ìº¡ì²˜")
        print("="*60)
        print(f"ì €ì¥ ìœ„ì¹˜: {self.save_dir}")
        print("-"*60)
        print("ì¡°ì‘ ë°©ë²•:")
        print("  [SPACE] - ì´ë¯¸ì§€ ìº¡ì²˜ (ì²´ìŠ¤ë³´ë“œ ê²€ì¶œ ì‹œ)")
        print("  [Q]     - ì¢…ë£Œ")
        print("="*60)
        
        while True:
            ret_l, frame_l = self.cap_left.read()
            ret_r, frame_r = self.cap_right.read()
            
            if not ret_l or not ret_r:
                print("âŒ ì¹´ë©”ë¼ ì½ê¸° ì‹¤íŒ¨")
                break
            
            # ì²´ìŠ¤ë³´ë“œ ê²€ì¶œ
            gray_l = cv2.cvtColor(frame_l, cv2.COLOR_BGR2GRAY)
            gray_r = cv2.cvtColor(frame_r, cv2.COLOR_BGR2GRAY)
            
            found_l, corners_l = cv2.findChessboardCorners(
                gray_l, self.checkerboard_size,
                cv2.CALIB_CB_ADAPTIVE_THRESH + cv2.CALIB_CB_NORMALIZE_IMAGE
            )
            found_r, corners_r = cv2.findChessboardCorners(
                gray_r, self.checkerboard_size,
                cv2.CALIB_CB_ADAPTIVE_THRESH + cv2.CALIB_CB_NORMALIZE_IMAGE
            )
            
            # ë””ìŠ¤í”Œë ˆì´ìš© ë³µì‚¬ë³¸
            display_l = frame_l.copy()
            display_r = frame_r.copy()
            
            # ì²´ìŠ¤ë³´ë“œ í‘œì‹œ
            if found_l:
                cv2.drawChessboardCorners(display_l, self.checkerboard_size, corners_l, found_l)
            if found_r:
                cv2.drawChessboardCorners(display_r, self.checkerboard_size, corners_r, found_r)
            
            # ìƒíƒœ í‘œì‹œ
            status_l = "âœ“ DETECTED" if found_l else "âœ— Not found"
            status_r = "âœ“ DETECTED" if found_r else "âœ— Not found"
            color_l = (0, 255, 0) if found_l else (0, 0, 255)
            color_r = (0, 255, 0) if found_r else (0, 0, 255)
            
            cv2.putText(display_l, f"LEFT: {status_l}", (10, 30),
                       cv2.FONT_HERSHEY_SIMPLEX, 1, color_l, 2)
            cv2.putText(display_r, f"RIGHT: {status_r}", (10, 30),
                       cv2.FONT_HERSHEY_SIMPLEX, 1, color_r, 2)
            cv2.putText(display_l, f"Captured: {self.image_count}", (10, 70),
                       cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 0), 2)
            
            # ë‘ ì´ë¯¸ì§€ í•©ì¹˜ê¸°
            display_l_resized = cv2.resize(display_l, (640, 360))
            display_r_resized = cv2.resize(display_r, (640, 360))
            combined = cv2.hconcat([display_l_resized, display_r_resized])
            
            cv2.imshow("Stereo Calibration Capture", combined)
            
            key = cv2.waitKey(1) & 0xFF
            
            if key == ord(' '):  # SPACE: ìº¡ì²˜
                if found_l and found_r:
                    # ì´ë¯¸ì§€ ì €ì¥
                    cv2.imwrite(f"{self.save_dir}/left/img_{self.image_count:03d}.png", frame_l)
                    cv2.imwrite(f"{self.save_dir}/right/img_{self.image_count:03d}.png", frame_r)
                    self.image_count += 1
                    print(f"âœ… ìº¡ì²˜ ì™„ë£Œ: {self.image_count}ìŒ")
                else:
                    print("âŒ ì–‘ìª½ ëª¨ë‘ì—ì„œ ì²´ìŠ¤ë³´ë“œê°€ ê²€ì¶œë˜ì–´ì•¼ í•©ë‹ˆë‹¤.")
                    
            elif key == ord('q'):  # Q: ì¢…ë£Œ
                break
        
        self.cleanup()
        
    def cleanup(self):
        """ë¦¬ì†ŒìŠ¤ ì •ë¦¬"""
        self.cap_left.release()
        self.cap_right.release()
        cv2.destroyAllWindows()
        
        print("="*60)
        print(f"âœ… ìº¡ì²˜ ì™„ë£Œ: ì´ {self.image_count}ìŒ")
        print(f"ğŸ“ ì €ì¥ ìœ„ì¹˜: {self.save_dir}")
        print("="*60)


if __name__ == "__main__":
    # ì¹´ë©”ë¼ ì¸ë±ìŠ¤ëŠ” ì‹œìŠ¤í…œì— ë§ê²Œ ì¡°ì •í•˜ì„¸ìš”
    capture = StereoCalibrationCapture(left_idx=0, right_idx=2)
    capture.capture_loop()
```

---

## 5. ë‹¨ì¼ ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜

### 5.1 ì´ë¡ 

ë‹¨ì¼ ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ì€ ë‹¤ìŒì„ ì¶”ì¶œí•©ë‹ˆë‹¤:

```
ë‚´ë¶€ íŒŒë¼ë¯¸í„° í–‰ë ¬ K:
â”Œ               â”
â”‚ fx   0   cx  â”‚     fx, fy: ì´ˆì ê±°ë¦¬ (í”½ì…€)
â”‚  0  fy   cy  â”‚     cx, cy: ì£¼ì  (ì´ë¯¸ì§€ ì¤‘ì‹¬)
â”‚  0   0    1  â”‚
â””               â”˜

ì™œê³¡ ê³„ìˆ˜ D:
D = [k1, k2, p1, p2, k3]

k1, k2, k3: ë°©ì‚¬ ì™œê³¡ ê³„ìˆ˜
p1, p2: ì ‘ì„  ì™œê³¡ ê³„ìˆ˜
```

### 5.2 êµ¬í˜„

```python
"""
single_camera_calibration.py
ë‹¨ì¼ ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜
"""

import cv2
import numpy as np
import glob
import yaml


def calibrate_single_camera(image_dir, checkerboard_size=(9, 6), square_size=25.0):
    """
    ë‹¨ì¼ ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜
    
    Parameters:
    - image_dir: ì´ë¯¸ì§€ ë””ë ‰í† ë¦¬ ê²½ë¡œ
    - checkerboard_size: ë‚´ë¶€ ì½”ë„ˆ ìˆ˜ (ê°€ë¡œ, ì„¸ë¡œ)
    - square_size: ì •ì‚¬ê°í˜• í¬ê¸° (mm)
    
    Returns:
    - ret: RMS ì¬íˆ¬ì˜ ì˜¤ì°¨
    - K: ë‚´ë¶€ íŒŒë¼ë¯¸í„° í–‰ë ¬ (3x3)
    - D: ì™œê³¡ ê³„ìˆ˜ (1x5)
    - rvecs: íšŒì „ ë²¡í„° ë¦¬ìŠ¤íŠ¸
    - tvecs: ë³‘ì§„ ë²¡í„° ë¦¬ìŠ¤íŠ¸
    """
    
    # 3D ê°ì²´ ì  ì¤€ë¹„ (ì²´ìŠ¤ë³´ë“œ ì¢Œí‘œ)
    objp = np.zeros((checkerboard_size[0] * checkerboard_size[1], 3), np.float32)
    objp[:, :2] = np.mgrid[0:checkerboard_size[0], 0:checkerboard_size[1]].T.reshape(-1, 2)
    objp *= square_size  # ì‹¤ì œ í¬ê¸°ë¡œ ìŠ¤ì¼€ì¼ë§
    
    obj_points = []  # 3D ì 
    img_points = []  # 2D ì 
    
    # ì´ë¯¸ì§€ íŒŒì¼ ë¡œë“œ
    images = sorted(glob.glob(f"{image_dir}/*.png"))
    
    if len(images) == 0:
        print(f"âŒ ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {image_dir}")
        return None, None, None, None, None
    
    print(f"ğŸ“ ì´ë¯¸ì§€ ë¡œë“œ: {len(images)}ê°œ")
    
    img_shape = None
    successful = 0
    
    for img_path in images:
        img = cv2.imread(img_path)
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        
        if img_shape is None:
            img_shape = gray.shape[::-1]  # (width, height)
        
        # ì²´ìŠ¤ë³´ë“œ ì½”ë„ˆ ê²€ì¶œ
        ret, corners = cv2.findChessboardCorners(
            gray, checkerboard_size,
            cv2.CALIB_CB_ADAPTIVE_THRESH + cv2.CALIB_CB_NORMALIZE_IMAGE
        )
        
        if ret:
            # ì„œë¸Œí”½ì…€ ì •í™•ë„ë¡œ ì½”ë„ˆ ì •ë°€í™”
            criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
            corners_refined = cv2.cornerSubPix(gray, corners, (11, 11), (-1, -1), criteria)
            
            obj_points.append(objp)
            img_points.append(corners_refined)
            successful += 1
    
    print(f"âœ… ì²´ìŠ¤ë³´ë“œ ê²€ì¶œ: {successful}/{len(images)}ê°œ ì„±ê³µ")
    
    if successful < 10:
        print("âŒ ìµœì†Œ 10ê°œ ì´ìƒì˜ ì´ë¯¸ì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤.")
        return None, None, None, None, None
    
    # ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹¤í–‰
    print("ğŸ”„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì§„í–‰ ì¤‘...")
    
    ret, K, D, rvecs, tvecs = cv2.calibrateCamera(
        obj_points, img_points, img_shape, None, None,
        flags=cv2.CALIB_FIX_K3  # k3ëŠ” ë³´í†µ 0ìœ¼ë¡œ ê³ ì •
    )
    
    print(f"\n{'='*50}")
    print("ğŸ“Š ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê²°ê³¼")
    print(f"{'='*50}")
    print(f"RMS ì¬íˆ¬ì˜ ì˜¤ì°¨: {ret:.4f} í”½ì…€")
    print(f"\në‚´ë¶€ íŒŒë¼ë¯¸í„° í–‰ë ¬ K:")
    print(f"  fx = {K[0,0]:.2f}")
    print(f"  fy = {K[1,1]:.2f}")
    print(f"  cx = {K[0,2]:.2f}")
    print(f"  cy = {K[1,2]:.2f}")
    print(f"\nì™œê³¡ ê³„ìˆ˜ D:")
    print(f"  k1 = {D[0,0]:.6f}")
    print(f"  k2 = {D[0,1]:.6f}")
    print(f"  p1 = {D[0,2]:.6f}")
    print(f"  p2 = {D[0,3]:.6f}")
    print(f"  k3 = {D[0,4]:.6f}")
    
    return ret, K, D, rvecs, tvecs


if __name__ == "__main__":
    # ì‚¬ìš© ì˜ˆì‹œ
    ret, K, D, rvecs, tvecs = calibrate_single_camera(
        "calibration_images/left",
        checkerboard_size=(9, 6),
        square_size=25.0
    )
```

---

## 6. ìŠ¤í…Œë ˆì˜¤ ìº˜ë¦¬ë¸Œë ˆì´ì…˜

### 6.1 ì´ë¡ 

ìŠ¤í…Œë ˆì˜¤ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ì€ ë‘ ì¹´ë©”ë¼ ê°„ì˜ ìƒëŒ€ì  ìœ„ì¹˜ ê´€ê³„ë¥¼ êµ¬í•©ë‹ˆë‹¤:

```
ì˜¤ë¥¸ìª½ ì¹´ë©”ë¼ ì¢Œí‘œ = R Ã— ì™¼ìª½ ì¹´ë©”ë¼ ì¢Œí‘œ + T

R: 3Ã—3 íšŒì „ í–‰ë ¬ (ë‘ ì¹´ë©”ë¼ ê°„ íšŒì „)
T: 3Ã—1 ë³‘ì§„ ë²¡í„° (ë‘ ì¹´ë©”ë¼ ê°„ ì´ë™, ë² ì´ìŠ¤ë¼ì¸ í¬í•¨)

ì´ìƒì ì¸ ê²½ìš° (ì™„ë²½íˆ í‰í–‰ ì •ë ¬):
    â”Œ           â”         â”Œ      â”
R = â”‚ 1  0  0   â”‚    T =  â”‚ -85  â”‚  (ë² ì´ìŠ¤ë¼ì¸ 85mm)
    â”‚ 0  1  0   â”‚         â”‚  0   â”‚
    â”‚ 0  0  1   â”‚         â”‚  0   â”‚
    â””           â”˜         â””      â”˜
```

### 6.2 êµ¬í˜„

```python
"""
stereo_calibration.py
ìŠ¤í…Œë ˆì˜¤ ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜
"""

import cv2
import numpy as np
import glob
import yaml
import os


class StereoCalibrator:
    def __init__(self, checkerboard_size=(9, 6), square_size=25.0):
        """
        Parameters:
        - checkerboard_size: ë‚´ë¶€ ì½”ë„ˆ ìˆ˜ (ê°€ë¡œ, ì„¸ë¡œ)
        - square_size: ì •ì‚¬ê°í˜• í¬ê¸° (mm)
        """
        self.checkerboard_size = checkerboard_size
        self.square_size = square_size
        
        # 3D ê°ì²´ ì  ì¤€ë¹„
        self.objp = np.zeros((checkerboard_size[0] * checkerboard_size[1], 3), np.float32)
        self.objp[:, :2] = np.mgrid[0:checkerboard_size[0], 0:checkerboard_size[1]].T.reshape(-1, 2)
        self.objp *= square_size
        
        # ê²°ê³¼ ì €ì¥ìš©
        self.K1 = None
        self.D1 = None
        self.K2 = None
        self.D2 = None
        self.R = None
        self.T = None
        self.E = None
        self.F = None
        self.R1 = None
        self.R2 = None
        self.P1 = None
        self.P2 = None
        self.Q = None
        self.img_size = None
        
    def find_corners(self, left_dir, right_dir):
        """ì–‘ìª½ ì´ë¯¸ì§€ì—ì„œ ì²´ìŠ¤ë³´ë“œ ì½”ë„ˆ ê²€ì¶œ"""
        
        left_images = sorted(glob.glob(f"{left_dir}/*.png"))
        right_images = sorted(glob.glob(f"{right_dir}/*.png"))
        
        if len(left_images) != len(right_images):
            print(f"âŒ ì´ë¯¸ì§€ ìˆ˜ ë¶ˆì¼ì¹˜: Left={len(left_images)}, Right={len(right_images)}")
            return None, None, None
        
        obj_points = []
        left_points = []
        right_points = []
        
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
        
        print(f"ğŸ“ ì´ë¯¸ì§€ ì²˜ë¦¬ ì¤‘: {len(left_images)}ìŒ")
        
        for i, (left_path, right_path) in enumerate(zip(left_images, right_images)):
            img_l = cv2.imread(left_path)
            img_r = cv2.imread(right_path)
            
            gray_l = cv2.cvtColor(img_l, cv2.COLOR_BGR2GRAY)
            gray_r = cv2.cvtColor(img_r, cv2.COLOR_BGR2GRAY)
            
            if self.img_size is None:
                self.img_size = gray_l.shape[::-1]
            
            # ì½”ë„ˆ ê²€ì¶œ
            ret_l, corners_l = cv2.findChessboardCorners(
                gray_l, self.checkerboard_size,
                cv2.CALIB_CB_ADAPTIVE_THRESH + cv2.CALIB_CB_NORMALIZE_IMAGE
            )
            ret_r, corners_r = cv2.findChessboardCorners(
                gray_r, self.checkerboard_size,
                cv2.CALIB_CB_ADAPTIVE_THRESH + cv2.CALIB_CB_NORMALIZE_IMAGE
            )
            
            if ret_l and ret_r:
                # ì„œë¸Œí”½ì…€ ì •ë°€í™”
                corners_l = cv2.cornerSubPix(gray_l, corners_l, (11, 11), (-1, -1), criteria)
                corners_r = cv2.cornerSubPix(gray_r, corners_r, (11, 11), (-1, -1), criteria)
                
                obj_points.append(self.objp)
                left_points.append(corners_l)
                right_points.append(corners_r)
                
        print(f"âœ… ì½”ë„ˆ ê²€ì¶œ ì„±ê³µ: {len(obj_points)}/{len(left_images)}ìŒ")
        
        return obj_points, left_points, right_points
    
    def calibrate(self, left_dir, right_dir):
        """ìŠ¤í…Œë ˆì˜¤ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹¤í–‰"""
        
        # ì½”ë„ˆ ê²€ì¶œ
        obj_points, left_points, right_points = self.find_corners(left_dir, right_dir)
        
        if obj_points is None or len(obj_points) < 10:
            print("âŒ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ì„ ìœ„í•œ ì¶©ë¶„í•œ ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return False
        
        print("\nğŸ”„ ë‹¨ì¼ ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜...")
        
        # ì™¼ìª½ ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜
        ret1, self.K1, self.D1, _, _ = cv2.calibrateCamera(
            obj_points, left_points, self.img_size, None, None
        )
        print(f"  ì™¼ìª½ ì¹´ë©”ë¼ RMS ì˜¤ì°¨: {ret1:.4f}")
        
        # ì˜¤ë¥¸ìª½ ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜
        ret2, self.K2, self.D2, _, _ = cv2.calibrateCamera(
            obj_points, right_points, self.img_size, None, None
        )
        print(f"  ì˜¤ë¥¸ìª½ ì¹´ë©”ë¼ RMS ì˜¤ì°¨: {ret2:.4f}")
        
        print("\nğŸ”„ ìŠ¤í…Œë ˆì˜¤ ìº˜ë¦¬ë¸Œë ˆì´ì…˜...")
        
        # ìŠ¤í…Œë ˆì˜¤ ìº˜ë¦¬ë¸Œë ˆì´ì…˜
        flags = cv2.CALIB_FIX_INTRINSIC  # ë‚´ë¶€ íŒŒë¼ë¯¸í„° ê³ ì •
        
        ret, self.K1, self.D1, self.K2, self.D2, self.R, self.T, self.E, self.F = \
            cv2.stereoCalibrate(
                obj_points, left_points, right_points,
                self.K1, self.D1, self.K2, self.D2,
                self.img_size, flags=flags,
                criteria=(cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 1e-5)
            )
        
        print(f"\n{'='*60}")
        print("ğŸ“Š ìŠ¤í…Œë ˆì˜¤ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê²°ê³¼")
        print(f"{'='*60}")
        print(f"RMS ì¬íˆ¬ì˜ ì˜¤ì°¨: {ret:.4f} í”½ì…€")
        
        # ë² ì´ìŠ¤ë¼ì¸ ê³„ì‚°
        baseline = np.linalg.norm(self.T)
        print(f"\në² ì´ìŠ¤ë¼ì¸: {baseline:.2f} mm")
        
        print(f"\në³‘ì§„ ë²¡í„° T (mm):")
        print(f"  Tx = {self.T[0,0]:.2f}")
        print(f"  Ty = {self.T[1,0]:.2f}")
        print(f"  Tz = {self.T[2,0]:.2f}")
        
        # íšŒì „ ê°ë„ ê³„ì‚°
        rvec, _ = cv2.Rodrigues(self.R)
        angles = np.degrees(rvec.flatten())
        print(f"\níšŒì „ ê°ë„ (degrees):")
        print(f"  Rx = {angles[0]:.3f}Â°")
        print(f"  Ry = {angles[1]:.3f}Â°")
        print(f"  Rz = {angles[2]:.3f}Â°")
        
        return True
    
    def rectify(self, alpha=0):
        """
        ìŠ¤í…Œë ˆì˜¤ ì •ë¥˜ ê³„ì‚°
        
        Parameters:
        - alpha: 0=ìœ íš¨í”½ì…€ë§Œ, 1=ëª¨ë“ í”½ì…€
        """
        
        if self.K1 is None:
            print("âŒ ë¨¼ì € calibrate()ë¥¼ ì‹¤í–‰í•˜ì„¸ìš”.")
            return False
        
        print("\nğŸ”„ ìŠ¤í…Œë ˆì˜¤ ì •ë¥˜ ê³„ì‚°...")
        
        self.R1, self.R2, self.P1, self.P2, self.Q, roi1, roi2 = cv2.stereoRectify(
            self.K1, self.D1, self.K2, self.D2,
            self.img_size, self.R, self.T,
            flags=cv2.CALIB_ZERO_DISPARITY,
            alpha=alpha
        )
        
        print(f"  ì™¼ìª½ ROI: {roi1}")
        print(f"  ì˜¤ë¥¸ìª½ ROI: {roi2}")
        
        # ì •ë¥˜ ë§µ ìƒì„±
        self.map1_left, self.map2_left = cv2.initUndistortRectifyMap(
            self.K1, self.D1, self.R1, self.P1, self.img_size, cv2.CV_32FC1
        )
        self.map1_right, self.map2_right = cv2.initUndistortRectifyMap(
            self.K2, self.D2, self.R2, self.P2, self.img_size, cv2.CV_32FC1
        )
        
        print("âœ… ì •ë¥˜ ë§µ ìƒì„± ì™„ë£Œ")
        
        return True
    
    def save_parameters(self, filename="stereo_params.yaml"):
        """ìº˜ë¦¬ë¸Œë ˆì´ì…˜ íŒŒë¼ë¯¸í„° ì €ì¥"""
        
        params = {
            'image_size': list(self.img_size),
            'K1': self.K1.tolist(),
            'D1': self.D1.tolist(),
            'K2': self.K2.tolist(),
            'D2': self.D2.tolist(),
            'R': self.R.tolist(),
            'T': self.T.tolist(),
            'E': self.E.tolist(),
            'F': self.F.tolist(),
            'R1': self.R1.tolist(),
            'R2': self.R2.tolist(),
            'P1': self.P1.tolist(),
            'P2': self.P2.tolist(),
            'Q': self.Q.tolist(),
            'baseline_mm': float(np.linalg.norm(self.T))
        }
        
        with open(filename, 'w') as f:
            yaml.dump(params, f, default_flow_style=False)
        
        print(f"\nâœ… íŒŒë¼ë¯¸í„° ì €ì¥: {filename}")
        
    def load_parameters(self, filename="stereo_params.yaml"):
        """ìº˜ë¦¬ë¸Œë ˆì´ì…˜ íŒŒë¼ë¯¸í„° ë¡œë“œ"""
        
        with open(filename, 'r') as f:
            params = yaml.safe_load(f)
        
        self.img_size = tuple(params['image_size'])
        self.K1 = np.array(params['K1'])
        self.D1 = np.array(params['D1'])
        self.K2 = np.array(params['K2'])
        self.D2 = np.array(params['D2'])
        self.R = np.array(params['R'])
        self.T = np.array(params['T'])
        self.E = np.array(params['E'])
        self.F = np.array(params['F'])
        self.R1 = np.array(params['R1'])
        self.R2 = np.array(params['R2'])
        self.P1 = np.array(params['P1'])
        self.P2 = np.array(params['P2'])
        self.Q = np.array(params['Q'])
        
        # ì •ë¥˜ ë§µ ì¬ìƒì„±
        self.map1_left, self.map2_left = cv2.initUndistortRectifyMap(
            self.K1, self.D1, self.R1, self.P1, self.img_size, cv2.CV_32FC1
        )
        self.map1_right, self.map2_right = cv2.initUndistortRectifyMap(
            self.K2, self.D2, self.R2, self.P2, self.img_size, cv2.CV_32FC1
        )
        
        print(f"âœ… íŒŒë¼ë¯¸í„° ë¡œë“œ: {filename}")
        
    def rectify_images(self, img_left, img_right):
        """ì´ë¯¸ì§€ ì •ë¥˜ ì ìš©"""
        
        rectified_left = cv2.remap(img_left, self.map1_left, self.map2_left, cv2.INTER_LINEAR)
        rectified_right = cv2.remap(img_right, self.map1_right, self.map2_right, cv2.INTER_LINEAR)
        
        return rectified_left, rectified_right


if __name__ == "__main__":
    # ì‚¬ìš© ì˜ˆì‹œ
    calibrator = StereoCalibrator(checkerboard_size=(9, 6), square_size=25.0)
    
    # ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹¤í–‰
    if calibrator.calibrate("calibration_images/left", "calibration_images/right"):
        # ì •ë¥˜ ê³„ì‚°
        calibrator.rectify(alpha=0)
        
        # íŒŒë¼ë¯¸í„° ì €ì¥
        calibrator.save_parameters("stereo_params.yaml")
```

---

## 7. ìŠ¤í…Œë ˆì˜¤ ì •ë¥˜

### 7.1 ì •ë¥˜ ê²°ê³¼ ì‹œê°í™”

```python
"""
visualize_rectification.py
ì •ë¥˜ ê²°ê³¼ ì‹œê°í™”
"""

import cv2
import numpy as np


def draw_epipolar_lines(img_left, img_right, num_lines=20):
    """
    ì •ë¥˜ëœ ì´ë¯¸ì§€ì— ì—í”¼í´ë¼ ë¼ì¸ ê·¸ë¦¬ê¸°
    ì •ë¥˜ê°€ ì˜ ë˜ì—ˆìœ¼ë©´ ìˆ˜í‰ì„ ì´ ì–‘ìª½ ì´ë¯¸ì§€ì—ì„œ ê°™ì€ ë†’ì´ë¥¼ ì§€ë‚¨
    """
    
    h, w = img_left.shape[:2]
    
    # ë³µì‚¬ë³¸ ìƒì„±
    vis_left = img_left.copy()
    vis_right = img_right.copy()
    
    # ìˆ˜í‰ì„  ê·¸ë¦¬ê¸°
    colors = [(0, 0, 255), (0, 255, 0), (255, 0, 0), (255, 255, 0), (255, 0, 255)]
    
    for i in range(num_lines):
        y = int(h * (i + 1) / (num_lines + 1))
        color = colors[i % len(colors)]
        cv2.line(vis_left, (0, y), (w, y), color, 1)
        cv2.line(vis_right, (0, y), (w, y), color, 1)
    
    # í•©ì¹˜ê¸°
    combined = cv2.hconcat([vis_left, vis_right])
    
    # ì—°ê²°ì„  (ì¤‘ì•™)
    for i in range(num_lines):
        y = int(h * (i + 1) / (num_lines + 1))
        color = colors[i % len(colors)]
        cv2.line(combined, (w-5, y), (w+5, y), color, 2)
    
    return combined


def compare_before_after(img_left, img_right, calibrator):
    """ì •ë¥˜ ì „í›„ ë¹„êµ"""
    
    # ì •ë¥˜ ì ìš©
    rect_left, rect_right = calibrator.rectify_images(img_left, img_right)
    
    # ì—í”¼í´ë¼ ë¼ì¸ ê·¸ë¦¬ê¸°
    before = draw_epipolar_lines(img_left, img_right, num_lines=15)
    after = draw_epipolar_lines(rect_left, rect_right, num_lines=15)
    
    # í¬ê¸° ì¡°ì •
    scale = 0.5
    before = cv2.resize(before, None, fx=scale, fy=scale)
    after = cv2.resize(after, None, fx=scale, fy=scale)
    
    # ë ˆì´ë¸” ì¶”ê°€
    cv2.putText(before, "BEFORE Rectification", (10, 30),
               cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 255), 2)
    cv2.putText(after, "AFTER Rectification", (10, 30),
               cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
    
    # ì„¸ë¡œë¡œ í•©ì¹˜ê¸°
    result = cv2.vconcat([before, after])
    
    return result


if __name__ == "__main__":
    from stereo_calibration import StereoCalibrator
    
    # ìº˜ë¦¬ë¸Œë ˆì´í„° ë¡œë“œ
    calibrator = StereoCalibrator()
    calibrator.load_parameters("stereo_params.yaml")
    
    # í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ ë¡œë“œ
    img_left = cv2.imread("test_left.png")
    img_right = cv2.imread("test_right.png")
    
    # ë¹„êµ ì´ë¯¸ì§€ ìƒì„±
    comparison = compare_before_after(img_left, img_right, calibrator)
    
    cv2.imshow("Rectification Comparison", comparison)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    
    cv2.imwrite("rectification_comparison.png", comparison)
    print("âœ… ì €ì¥ë¨: rectification_comparison.png")
```

---

## 8. ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê²€ì¦

### 8.1 í’ˆì§ˆ ì§€í‘œ

| ì§€í‘œ | ì–‘í˜¸ | ë³´í†µ | ë¶ˆëŸ‰ |
|------|------|------|------|
| RMS ì¬íˆ¬ì˜ ì˜¤ì°¨ | < 0.5 px | 0.5-1.0 px | > 1.0 px |
| ì—í”¼í´ë¼ ë¼ì¸ ì •ë ¬ | < 0.5 px | 0.5-1.0 px | > 1.0 px |
| ë² ì´ìŠ¤ë¼ì¸ ì˜¤ì°¨ | < 1% | 1-3% | > 3% |

### 8.2 ê²€ì¦ ì½”ë“œ

```python
"""
validate_calibration.py
ìº˜ë¦¬ë¸Œë ˆì´ì…˜ í’ˆì§ˆ ê²€ì¦
"""

import cv2
import numpy as np


def compute_epipolar_error(calibrator, left_points, right_points):
    """
    ì—í”¼í´ë¼ ë¼ì¸ ì˜¤ì°¨ ê³„ì‚°
    ì •ë¥˜ í›„ ëŒ€ì‘ì ë“¤ì´ ê°™ì€ í–‰ì— ìˆëŠ”ì§€ ê²€ì¦
    """
    
    errors = []
    
    for lp, rp in zip(left_points, right_points):
        # ì •ë¥˜ ì ìš©
        lp_rect = cv2.undistortPoints(lp, calibrator.K1, calibrator.D1, 
                                       R=calibrator.R1, P=calibrator.P1)
        rp_rect = cv2.undistortPoints(rp, calibrator.K2, calibrator.D2,
                                       R=calibrator.R2, P=calibrator.P2)
        
        # yì¢Œí‘œ ì°¨ì´ ê³„ì‚°
        for l, r in zip(lp_rect.reshape(-1, 2), rp_rect.reshape(-1, 2)):
            error = abs(l[1] - r[1])  # yì¢Œí‘œ ì°¨ì´
            errors.append(error)
    
    errors = np.array(errors)
    
    print(f"\n{'='*50}")
    print("ğŸ“Š ì—í”¼í´ë¼ ì˜¤ì°¨ ë¶„ì„")
    print(f"{'='*50}")
    print(f"í‰ê·  ì˜¤ì°¨: {np.mean(errors):.4f} í”½ì…€")
    print(f"ìµœëŒ€ ì˜¤ì°¨: {np.max(errors):.4f} í”½ì…€")
    print(f"í‘œì¤€í¸ì°¨: {np.std(errors):.4f} í”½ì…€")
    print(f"90% ì´ë‚´: {np.percentile(errors, 90):.4f} í”½ì…€")
    
    return errors


def validate_baseline(calibrator, expected_baseline_mm):
    """ë² ì´ìŠ¤ë¼ì¸ ê²€ì¦"""
    
    measured_baseline = np.linalg.norm(calibrator.T)
    error_percent = abs(measured_baseline - expected_baseline_mm) / expected_baseline_mm * 100
    
    print(f"\n{'='*50}")
    print("ğŸ“Š ë² ì´ìŠ¤ë¼ì¸ ê²€ì¦")
    print(f"{'='*50}")
    print(f"ì˜ˆìƒ ë² ì´ìŠ¤ë¼ì¸: {expected_baseline_mm:.2f} mm")
    print(f"ì¸¡ì • ë² ì´ìŠ¤ë¼ì¸: {measured_baseline:.2f} mm")
    print(f"ì˜¤ì°¨: {error_percent:.2f}%")
    
    if error_percent < 1:
        print("âœ… ë² ì´ìŠ¤ë¼ì¸ ì •í™•ë„: ì–‘í˜¸")
    elif error_percent < 3:
        print("âš ï¸ ë² ì´ìŠ¤ë¼ì¸ ì •í™•ë„: ë³´í†µ")
    else:
        print("âŒ ë² ì´ìŠ¤ë¼ì¸ ì •í™•ë„: ë¶ˆëŸ‰ - ì¬ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê¶Œì¥")
    
    return error_percent


def full_validation(calibrator, left_dir, right_dir, expected_baseline_mm=85.0):
    """ì „ì²´ ê²€ì¦ ì‹¤í–‰"""
    
    print("\n" + "="*60)
    print("ğŸ” ìº˜ë¦¬ë¸Œë ˆì´ì…˜ í’ˆì§ˆ ê²€ì¦")
    print("="*60)
    
    # ì½”ë„ˆ ê²€ì¶œ
    obj_points, left_points, right_points = calibrator.find_corners(left_dir, right_dir)
    
    # ì—í”¼í´ë¼ ì˜¤ì°¨
    errors = compute_epipolar_error(calibrator, left_points, right_points)
    
    # ë² ì´ìŠ¤ë¼ì¸ ê²€ì¦
    baseline_error = validate_baseline(calibrator, expected_baseline_mm)
    
    # ì¢…í•© í‰ê°€
    print(f"\n{'='*60}")
    print("ğŸ“‹ ì¢…í•© í‰ê°€")
    print(f"{'='*60}")
    
    avg_error = np.mean(errors)
    
    if avg_error < 0.5 and baseline_error < 1:
        print("âœ… ìº˜ë¦¬ë¸Œë ˆì´ì…˜ í’ˆì§ˆ: ìš°ìˆ˜")
        print("   ìŠ¤í…Œë ˆì˜¤ ë§¤ì¹­ì— ì í•©í•©ë‹ˆë‹¤.")
    elif avg_error < 1.0 and baseline_error < 3:
        print("âš ï¸ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ í’ˆì§ˆ: ì–‘í˜¸")
        print("   ì¼ë°˜ì ì¸ ì‚¬ìš©ì— ì í•©í•©ë‹ˆë‹¤.")
    else:
        print("âŒ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ í’ˆì§ˆ: ë¶ˆëŸ‰")
        print("   ì¬ìº˜ë¦¬ë¸Œë ˆì´ì…˜ì„ ê¶Œì¥í•©ë‹ˆë‹¤.")
        print("\nê¶Œì¥ì‚¬í•­:")
        print("  1. ë” ë§ì€ ì´ë¯¸ì§€ ì‚¬ìš© (30ì¥ ì´ìƒ)")
        print("  2. ë‹¤ì–‘í•œ ê°ë„ì™€ ìœ„ì¹˜ì—ì„œ ì´¬ì˜")
        print("  3. ì´ë¯¸ì§€ ê°€ì¥ìë¦¬ì—ë„ ì²´ìŠ¤ë³´ë“œ ë°°ì¹˜")
        print("  4. ì²´ìŠ¤ë³´ë“œ í‰í‰í•œì§€ í™•ì¸")
```

---

## 9. ì‹¤ìŠµ ì½”ë“œ

### 9.1 ì „ì²´ íŒŒì´í”„ë¼ì¸

```python
"""
full_calibration_pipeline.py
ìŠ¤í…Œë ˆì˜¤ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì „ì²´ íŒŒì´í”„ë¼ì¸
"""

import cv2
import numpy as np
import os
from stereo_calibration import StereoCalibrator
from validate_calibration import full_validation


def run_full_pipeline():
    """ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì „ì²´ íŒŒì´í”„ë¼ì¸ ì‹¤í–‰"""
    
    print("="*60)
    print("ğŸ¯ ìŠ¤í…Œë ˆì˜¤ ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ íŒŒì´í”„ë¼ì¸")
    print("="*60)
    
    # ì„¤ì •
    CHECKERBOARD_SIZE = (9, 6)  # ë‚´ë¶€ ì½”ë„ˆ ìˆ˜
    SQUARE_SIZE = 25.0          # mm
    EXPECTED_BASELINE = 85.0    # mm
    
    LEFT_DIR = "calibration_images/left"
    RIGHT_DIR = "calibration_images/right"
    OUTPUT_FILE = "stereo_params.yaml"
    
    # 1. ì´ë¯¸ì§€ í™•ì¸
    print("\n[1/5] ì´ë¯¸ì§€ í™•ì¸...")
    left_count = len([f for f in os.listdir(LEFT_DIR) if f.endswith('.png')])
    right_count = len([f for f in os.listdir(RIGHT_DIR) if f.endswith('.png')])
    print(f"  ì™¼ìª½ ì´ë¯¸ì§€: {left_count}ê°œ")
    print(f"  ì˜¤ë¥¸ìª½ ì´ë¯¸ì§€: {right_count}ê°œ")
    
    if left_count < 15 or right_count < 15:
        print("âŒ ìµœì†Œ 15ìŒ ì´ìƒì˜ ì´ë¯¸ì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤.")
        return
    
    # 2. ìº˜ë¦¬ë¸Œë ˆì´í„° ì´ˆê¸°í™”
    print("\n[2/5] ìº˜ë¦¬ë¸Œë ˆì´í„° ì´ˆê¸°í™”...")
    calibrator = StereoCalibrator(
        checkerboard_size=CHECKERBOARD_SIZE,
        square_size=SQUARE_SIZE
    )
    
    # 3. ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹¤í–‰
    print("\n[3/5] ìŠ¤í…Œë ˆì˜¤ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹¤í–‰...")
    if not calibrator.calibrate(LEFT_DIR, RIGHT_DIR):
        print("âŒ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹¤íŒ¨")
        return
    
    # 4. ì •ë¥˜ ê³„ì‚°
    print("\n[4/5] ìŠ¤í…Œë ˆì˜¤ ì •ë¥˜ ê³„ì‚°...")
    calibrator.rectify(alpha=0)
    
    # 5. ê²€ì¦
    print("\n[5/5] ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê²€ì¦...")
    full_validation(calibrator, LEFT_DIR, RIGHT_DIR, EXPECTED_BASELINE)
    
    # ì €ì¥
    calibrator.save_parameters(OUTPUT_FILE)
    
    print("\n" + "="*60)
    print("âœ… ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ!")
    print(f"ğŸ“ íŒŒë¼ë¯¸í„° ì €ì¥: {OUTPUT_FILE}")
    print("="*60)
    
    # ê²°ê³¼ ì‹œê°í™”
    print("\nì •ë¥˜ ê²°ê³¼ë¥¼ ì‹œê°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/n): ", end="")
    if input().lower() == 'y':
        visualize_result(calibrator, LEFT_DIR, RIGHT_DIR)


def visualize_result(calibrator, left_dir, right_dir):
    """ê²°ê³¼ ì‹œê°í™”"""
    
    import glob
    
    left_images = sorted(glob.glob(f"{left_dir}/*.png"))
    right_images = sorted(glob.glob(f"{right_dir}/*.png"))
    
    # ì²« ë²ˆì§¸ ì´ë¯¸ì§€ ìŒ ì‚¬ìš©
    img_left = cv2.imread(left_images[0])
    img_right = cv2.imread(right_images[0])
    
    # ì •ë¥˜ ì ìš©
    rect_left, rect_right = calibrator.rectify_images(img_left, img_right)
    
    # ì—í”¼í´ë¼ ë¼ì¸ ê·¸ë¦¬ê¸°
    h = rect_left.shape[0]
    for y in range(0, h, 50):
        color = tuple(np.random.randint(0, 255, 3).tolist())
        cv2.line(rect_left, (0, y), (rect_left.shape[1], y), color, 1)
        cv2.line(rect_right, (0, y), (rect_right.shape[1], y), color, 1)
    
    # í•©ì¹˜ê¸°
    combined = cv2.hconcat([
        cv2.resize(rect_left, (640, 360)),
        cv2.resize(rect_right, (640, 360))
    ])
    
    cv2.imshow("Rectified Stereo (press any key to close)", combined)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    
    cv2.imwrite("rectified_result.png", combined)
    print("âœ… ì €ì¥ë¨: rectified_result.png")


if __name__ == "__main__":
    run_full_pipeline()
```

---

## 10. íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

### 10.1 ì¼ë°˜ì ì¸ ë¬¸ì œì™€ í•´ê²°ì±…

| ë¬¸ì œ | ì›ì¸ | í•´ê²°ì±… |
|------|------|--------|
| ì²´ìŠ¤ë³´ë“œ ê²€ì¶œ ì‹¤íŒ¨ | ì¡°ëª… ë¶€ì¡±, ë°˜ì‚¬ | ì¡°ëª… ê°œì„ , ë¬´ê´‘ ì²´ìŠ¤ë³´ë“œ |
| RMS ì˜¤ì°¨ > 1.0 | ì´ë¯¸ì§€ ë¶€ì¡±, ë‹¤ì–‘ì„± ë¶€ì¡± | ë” ë§ì€ ì´ë¯¸ì§€, ë‹¤ì–‘í•œ ê°ë„ |
| ë² ì´ìŠ¤ë¼ì¸ ì˜¤ì°¨ í¼ | ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì´ë¯¸ì§€ í’ˆì§ˆ | ì •ì‚¬ê°í˜• í¬ê¸° ì •í™•íˆ ì¸¡ì • |
| ì •ë¥˜ í›„ ì´ë¯¸ì§€ ì˜ë¦¼ | alpha=0 ì„¤ì • | alpha=1ë¡œ ë³€ê²½ ë˜ëŠ” ROI ì‚¬ìš© |
| ì¹´ë©”ë¼ ë™ê¸°í™” ë¬¸ì œ | í”„ë ˆì„ ë¶ˆì¼ì¹˜ | ìº¡ì²˜ ì‹œ ì •ì§€ ìƒíƒœ ìœ ì§€ |

### 10.2 ì²´ìŠ¤ë³´ë“œ ê²€ì¶œ ê°œì„ 

```python
def find_corners_robust(gray, checkerboard_size):
    """ê°•ê±´í•œ ì½”ë„ˆ ê²€ì¶œ"""
    
    # ë°©ë²• 1: ê¸°ë³¸
    flags = cv2.CALIB_CB_ADAPTIVE_THRESH + cv2.CALIB_CB_NORMALIZE_IMAGE
    ret, corners = cv2.findChessboardCorners(gray, checkerboard_size, flags)
    
    if ret:
        return ret, corners
    
    # ë°©ë²• 2: ë¹ ë¥¸ ê²€ìƒ‰ ì¶”ê°€
    flags = cv2.CALIB_CB_ADAPTIVE_THRESH + cv2.CALIB_CB_NORMALIZE_IMAGE + cv2.CALIB_CB_FAST_CHECK
    ret, corners = cv2.findChessboardCorners(gray, checkerboard_size, flags)
    
    if ret:
        return ret, corners
    
    # ë°©ë²• 3: ì´ë¯¸ì§€ ì „ì²˜ë¦¬
    gray_eq = cv2.equalizeHist(gray)
    ret, corners = cv2.findChessboardCorners(gray_eq, checkerboard_size, flags)
    
    if ret:
        return ret, corners
    
    # ë°©ë²• 4: ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬
    gray_blur = cv2.GaussianBlur(gray, (5, 5), 0)
    ret, corners = cv2.findChessboardCorners(gray_blur, checkerboard_size, flags)
    
    return ret, corners
```

---

## ğŸ“ í•™ìŠµ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ì´ë¡  ì´í•´

- [ ] ë‚´ë¶€ íŒŒë¼ë¯¸í„°ì™€ ì™¸ë¶€ íŒŒë¼ë¯¸í„°ì˜ ì°¨ì´ë¥¼ ì„¤ëª…í•  ìˆ˜ ìˆë‹¤
- [ ] ì™œê³¡ ê³„ìˆ˜ì˜ ì˜ë¯¸ë¥¼ ì´í•´í–ˆë‹¤
- [ ] ìŠ¤í…Œë ˆì˜¤ ì •ë¥˜ì˜ ëª©ì ì„ ì„¤ëª…í•  ìˆ˜ ìˆë‹¤
- [ ] Q í–‰ë ¬ì„ ì´ìš©í•œ 3D ë³µì› ì›ë¦¬ë¥¼ ì´í•´í–ˆë‹¤

### ì‹¤ìŠµ ì™„ë£Œ

- [ ] ì²´ìŠ¤ë³´ë“œ íŒ¨í„´ ìƒì„± ë° ì¸ì‡„
- [ ] ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì´ë¯¸ì§€ 30ìŒ ì´ìƒ ìº¡ì²˜
- [ ] ë‹¨ì¼ ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ
- [ ] ìŠ¤í…Œë ˆì˜¤ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ
- [ ] ì •ë¥˜ ë§µ ìƒì„± ë° ì ìš©
- [ ] ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê²€ì¦ (RMS < 1.0)
- [ ] íŒŒë¼ë¯¸í„° íŒŒì¼ ì €ì¥ (.yaml)

---

## â¡ï¸ ë‹¤ìŒ ëª¨ë“ˆ

**[Module 03: ìŠ¤í…Œë ˆì˜¤ ë§¤ì¹­ & ê¹Šì´ ì¶”ì •](../Module_03_Stereo_Matching/README.md)**

ë‹¤ìŒ ëª¨ë“ˆì—ì„œëŠ” ìº˜ë¦¬ë¸Œë ˆì´ì…˜ëœ ìŠ¤í…Œë ˆì˜¤ ì¹´ë©”ë¼ë¥¼ ì‚¬ìš©í•˜ì—¬:
- Block Matching (BM) ì•Œê³ ë¦¬ì¦˜
- Semi-Global Block Matching (SGBM) ì•Œê³ ë¦¬ì¦˜
- Disparity Map ìƒì„±
- Depth Map ë³€í™˜

ì„ ì‹¤ìŠµí•©ë‹ˆë‹¤.

---

## ğŸ“„ ë¼ì´ì„ ìŠ¤

MIT License - ììœ ë¡­ê²Œ ì‚¬ìš©, ìˆ˜ì •, ë°°í¬ ê°€ëŠ¥
